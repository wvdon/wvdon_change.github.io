---
title: '数据库'
date: 2021-5-7 19:42:57
tags: [数据库]
categories: database
description: 数据库
---



# 数据库

## 基础

教程地址：[地址](https://www.bilibili.com/video/BV1NJ411J79W?p=42&spm_id_from=pageDriver)

安装建议：安装压缩包，非exe，便于卸载。

# mysql语法



连接数据库：

```sql
mysql -uroot -p123456 --连接数据库

update mysql.user set authentication_string=password('123456') where user='root' and
Host = 'localhost';-- 修改密码

flush privileges; --刷新权限

describe student;--显示数据库中所有表的信息

```

2.1 操作数据库

```sql
CREATE DATABASE IF NOT EXISTS webData; 
DROP DATABASE IF EXISTS webData; -- 删除数据库
```

2.2 数据库的列类型

数值

- tinyint 十分小的数据 ，一个字节
- smallint 较少的数据，两个字节
- int   标准整数，4个字节
- bigint 8个字节。
- float 浮点数 4个字节
- double 浮点数 8个字节
- decimal 字符串形式的浮点数  金融计算的时候，一般使用

字符串

- char 字符串固定大小 0-255
- varchar 可变字符串， 0-65535 常用的 string
- tinytext 微型文本 ，   2^8-1
- text 文本串  2^16-1

时间日期

    java.util.Date

- date YYYY-MM-DD ,日期格式
- time HH:mm:ss ，时间格式
- datetime  YYYY:MM-DD HH:mm:ss 最常用的时间格式
- timestamp 时间戳 ，1970.1.1到现在的毫秒数。
- year 年份表示

null

- 没有值，未知
- **==不要使用==**

2.3 数据库的字段属性（重点）

默认

自动递增

- 自动+1
- 设计唯一主键，必须是整数类型。

无符号 unsigned

- 不能为负

填充零 zerofill

- 不足的位数，使用0填充，int(3) ,5—005

非空 not null

- 如果不赋值，默认为null。

2.3 建表

```sql
create table if not exists 'test'( 
	'id' int not null default 0 comment '用户id' ,
  primary key('id')
)ENGINE=INNODB DEFAULT CHARSET=utf8
--commont 注释
```

修改已建好表的字段

`alter table test modify column id int not null default 0 comment '测试表id'`

2.4 数据表的类型

数据库引擎

Mysql 中 MyISAM 和 InnoDB 的区别有哪些？

> 默认使用 INNODB 
> 早期使用 MYISAM

[https://www.zhihu.com/question/20596402?sort=created](https://www.zhihu.com/question/20596402?sort=created)

2.5 修改表

```sql
--修改表名
ALTER TABLE oldTable RENAME AS newTable; 
--增加表的字段
ALTER TABLE oldTable ADD age INT(11);
--修改表的字段，约束
ALTER TABLE T MODIFY age VARCHAR(11) ---修改约束
ALTER TABLE T change age age1 INT(1);
```

modify与change区别：

二者都能修改表的属性，其中change修改需要制定两次列名，但是change可以修改列名，modify不能。

> modify不能字段重命名，只能修改字段类型和约束change可以给字段重命名，但是不能修改字段类型和约束。

DESC:

- 查看表结构的详细信息
- 降序排列数据

MySql常见约束

    六大约束

- NOT NULL

- DEFAULT

- PRIMARY KEY：保证唯一且非空

- UNIQUE: 唯一，用于保证该字段的值具有唯一性，可以为空。例如注册用户的手机号，身份证号等。

- CHECK ：检查约束，性别男女

- FOREIGN KEY ：外键，限制两个表的关系。用于保证字段值来自主表关联列的值。学生表的专业编号。

  添加约束时：

- 修改表时

- 创建表时

①列级约束

```sql
create table if not exists t_stuinfo(
    id int primary key,    #主键
    stuName varchar(20) not null,    #非空
    gender char(1) check(gender='男' or gender='女'),    #检查约束，MySql没有效果但不报错
    seat int unique,    #唯一约束
    age int default 18,    #默认（值）约束
    majorId int references major(id) #外键约束，MySql没有效果，但不报错
    );
```

②表级约束

```sql
create table if not exists t_stuinfo(
    id int,
    stuName varchar(20),
    gender char(1),
    seat int,
    age int,
    majorId int,
    constraint pk primary key(id),    #约束名随意，主键不生效，但不报错。
    constraint uq unique(seat),    #唯一约束
    constraint ck check(gender='男' or gender='女'),    #检查约束，MySql不支持此约束，不报错但不生效
    constraint fk_stuinfo_major foreign key(majorId) references major(id)    #外键约束
    );
```

修改表时添加约束：

1. 添加非空约束

`alter table 表名称 modify column 列名 列类型 not null;`

2.添加默认约束

`alter table 表名称 modify column 列名 列类型 default 默认值;`

3.添加主键

①列级约束方式

`alter table 表名称 modify column 列名 列类型 primary key;`

②表级约束方式

`alter table 表名称 add primary key(id);`

4.添加唯一

①列级约束

`alter table 表名称 modify column 列名 列类型 unique;`

②表级约束

`alter table 表名称 add unique(列名称);`

5，添加外键（列级写法可行，但无效果）

①表级约束

`alter table 表名称 add constraint fk_stuinfo_magor foreign key(magorId) references major(id);`

6.添加通用写法（语法）

①列级约束

`alter table 表名称 modify column 列名 列类型 新约束;`

②表级约束

`alter table 表名称 add constraint 约束名 约束类型(列名称) [外键的引用];`

修改表时删除约束

1.删除非空约束

`alter table 表名称 modify column 列名 列类型 [null];`

2.删除默认约束

`alter table 表名称 modify column 列名 列类型;`

3.删除主键

①

`alter table 表名称 modify column id int;`

②

`alter table 表名称 drop primary key;`

4.删除唯一

`alter table 表名称 drop index(索引名) 设置唯一时的名称;`

5.删除外键

`alter table 表名称 drop foreign key(索引名) 设置外键时的名称;`

🤷‍♂️总结：以上都是物理外键，数据库级别的外键，不建议使用（避免数据库过多造成困扰）

标识列

> 又称为自增长列，可以不用手动的插入值，系统提供默认的序列值

特点：

1.标识列必须和一个Key搭配（Key指主键、唯一、外键....）

2.一个表最多有一个标识列

3.标识列的类型只能是数值型

4.标识列可以通过SET auto_increment_increment = 3;设置步长（全局），可以通过插入行时手动插入标识列值设置起始值。

1.创建表时设置标识列

```sql
create table user(
     id int primary key auto_increment,
     name varchar(20)
     );
```

2.修改表时设置标识列

`alter table 表名称 modify column id int primary key auto_increment;`

3.修改表时删除标识列

`alter table 表名称 modify column id int primary key;`

    主键和唯一的区别？

  [参考](https://www.cnblogs.com/fanqisoft/p/10697866.html)

truncate与drop,delete的对比？

delete不会影响自增。truncate情况会影响，重置

二者都是删除表内容，不删除表结构。

TRUNCATE 重新设置，不影响事务。

DELETE删除的问题，重启数据库的时候：

- InnoDB 自增列会从1 开始，（若存在内存中，断电即失）
- MyISAM 继续从上一个自增量开始，（若存在文件中，不会丢失）

DML 与DQL

# DQL

> data query language

## SELECT

完整语法

select 列1 as 别名1, 列2 as 别名2 ,...
from 表1 as 表名1 left join 表2 as 表名2 on 表名1.字段=表名2.字段 ...
where 条件1 and/or 条件2 and/or?...
group by 列
having 条件1 and/or 条件2 and/or ... 过滤分组的记录必须满足的次要条件
order by 列1, 列2,...  
limit m,n ; 从m处开始获取n条
————————————————

```sql
-- 结果集中会自动去重复数据
SELECT DISTINCT Company FROM Orders

-- 取别名，包含与不包含
SELECT s.id from station s WHERE id in (13,14) and user_id not in (4);
-- 结果集中会自动去重复数据
SELECT DISTINCT company FROM Orders
-- 
```

AS:取别名（给列名称或者表名称取一个别名）

```sql
SELECT 'studentNo' AS 学号 FROM student AS s;
```

Concat(a,b) 拼接字段

```sql
SELECT CONCAT('姓名',studentName) AS 新名字 FROM student;
```

DISTINCT 去重

```sql
--查询那些同学添加了考试，成绩(无重复数据)
SELECT DISTINCT 'STUDENTNO' FROM result 
```

VERSION() 查看SQL版本

```sql
SELECT VERSION();
```

where 条件子句

[官网文档](https://dev.mysql.com/doc/refman/5.7/en/non-typed-operators.html) 表达式

- 逻辑表达
- 模糊查询

like中： %（代表0到多个字符） _（代表一个字符）

IN （具体的一个或者多个值） 不能用like

JOIN  联表查询

![](https://web.wvdon.com/Untitled.png)

自连接和联表查询

@TODO 联系 

limit 分页

- LIMIT 当前页 页面的大小

ORDER BY 排序

- 升序 ASC 默认
- 降序 DESC

常用函数和表达式：

[官网](https://dev.mysql.com/doc/refman/5.7/en/built-in-function-reference.html) 参加官网查询

聚合函数（常用）

- COUNT()

  下面都可以计算统计，但是其区别是？

  - count(列名,字段)  会忽略所有的NULL
  - count(*) 不会忽略null值
  - count(1)

```sql
> 1、COUNT有几种用法？
> 2、COUNT(字段名)和COUNT(*)的查询结果有什么不同？
> 3、COUNT(1)和COUNT(*)之间有什么不同？
> 4、COUNT(1)和COUNT(*)之间的效率哪个更高？
> 5、为什么《阿里巴巴Java开发手册》建议使用COUNT(*)
> 6、MySQL的MyISAM引擎对COUNT(*)做了哪些优化？
> 7、MySQL的InnoDB引擎对COUNT(*)做了哪些优化？
> 8、上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？
> 9、SELECT COUNT(*) 的时候，加不加where条件有差别吗？
> 10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？
```

[参考地址](https://www.cnblogs.com/hider/p/11726690.html)

- SUM
- AVG

HAVING 与 GROUP BY 区别

- WHERE是一个约束声明，是返回结构之前起作用的，且WHERE中不能使用聚合函数
- HAVAING是一个过滤声明，是在查询返回结果集之后对结构进行过滤的操作，在HAVING中可以使用聚合函数。

## UPDATE

**UPDATE 表名称 SET 列名称 = new values WHRER 列名称=value**

 

### 数据库级别的MD5加密

`UPDATE test SET PWD=MD5(pwd)`

```sql
--插入时加密：
INSERT INTO test VALUES(4,'X',MD5('123456'));
-- 校验
SELECT * FROM  test WHERE 'name' = 'xx' AND pwd=MD5('123456');
```

# 事务（很重要—概念）

> ACID

四种的含义。

- 原子性
- 一致性
- 持久性
- 隔离性

[https://blog.csdn.net/dengjili/article/details/82468576](https://blog.csdn.net/dengjili/article/details/82468576)

> 隔离导致的问题

- 脏读
- 不可重复读
- 虚读（幻读）

执行事务

```sql
START TRANSACTION
INSERT XXX
INSERT XXX
COMMIT 
-- 回滚
ROLLBACK 
-- 保存点
SAVEPOINT name
ROLLBACK TO SAVEPOINT name
REL
```

```java
try{
	//code
commit();
}catch(){
	rollback();
}
```

# 索引

> 帮助mysql更快速获取数据的数据结构。

⭐《MySQL索引背后的数据结构及算法原理》非常好的介绍

[http://blog.codinglabs.org/articles/theory-of-mysql-index.html](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

索引的分类：

- 主键索引 PRIMARY KEY
  - -唯一标识，不可重复，只能是一个列。(primary key = unique + not null)
- 唯一索引 UNIQUE KEY
  - 避免重复的列出现。
- 常规索引 KEY/INDEX  标志为：NORMAL
- 全文索引 FULLText

显示所有的索引信息：

`show index from student`

增加索引：

`alter table school.student add fulltext index 'studentname'('studentname')`

> 在实际操作过程中，应该选取表中哪些字段作为索引？

 1.  选择唯一性索引

1.  选择唯一性索引的值是唯一的。可以更快速的通过该索引来确定某条记录。例如学生学号。
1.  为经常需要排序，分组，和联合操作的字段建立索引
    1. 经常需要ORDER BY,GROUP BY DISTINCT ，UNION等操作的字段。

**3．为常作为查询条件的字段建立索引**

如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。

**4．限制索引的数目**

索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。

**5．尽量使用数据量少的索引**

如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR（100）类型的字段进行全文检索需要的时间肯定要比对CHAR（10）类型的字段需要的时间要多。

**6．尽量使用前缀来索引**

如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。

**7．删除不再使用或者很少使用的索引**

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

注意：选择索引的最终目的是为了使查询的速度变快。上面给出的原则是最基本的准则，但不能拘泥于上面的准则。读者要在以后的学习和工作中进行不断的实践。根据应用的实际情况进行分析和判断，选择最合适的索引方式。

举个例子来说，比如你在为某商场做一个会员卡的系统。这个系统有一个会员表（大致字段如下）：

> 会员编号   INT
> 会员姓名   VARCHAR(10)
> 会员身份证号码   VARCHAR(18)
> 会员电话   VARCHAR(10)
> 会员住址   VARCHAR(50)
> 会员备注信息  TEXT

那么这个会员编号，作为主键，使用 PRIMARY

会员姓名如果要建索引的话，那么就是普通的 INDEX

会员身份证号码如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）

会员备注信息如果需要建索引的话，可以选择 FULLTEXT，全文搜索。

 **EXPALIN:**

> 分析sql执行的状况

⭐【MySQL优化】——看懂explain [https://blog.csdn.net/jiadajing267/article/details/81269067](https://blog.csdn.net/jiadajing267/article/details/81269067)

> 索引原则：

- 索引不是越多越好
- 不要对经常变动数据加索引
- 小数据量的表不需要加索引
- 索引一般加在常用来查询的字段上。

> 索引的数据结构

Hash类型的索引。

索引的方法：他们几个都是 Btree :

## 数据库备份

> 为什么要备份。

- 保证数据不丢失
- 数据转移。

> 备份方式

- 直接拷贝物理文件

- 使用命令行导出 `mysqldump`

  ```sql
  -- 使用格式。-h主机 。。 数据库 数据表 地址
  mysqldump -hlocalhost -uroot -p123456 school student >D:/a.sql
  -- 多个表
  mysqldump -hlocalhost -uroot -p123456 school student result >D:/b.sql
  ```

  ```sql
  -- 导入数据库
  mysq > use school;
  mysql > source d:/b.sql
  ```

## 权限管理

### 用户管理

> SQL 界面

> SQL 命令操作 相当于对于user表进行操作。

修改密码：

`SET PASSWORD = PASSWORD(‘123456’);`

修改某个人的密码：

`SET PASSWORD for wvdon = PASSWORD('12345');`

重命名(源—新名字)：

`RENAME USER wvdon TO WEIDONG`

用户授权 ALL PRIVILEGES 全部的权限,库，表

```sql
-- 用户授权;ALL PRIVILEGES 全部的权限，库，表。(默认没有GRANT,不能给别的用户授权)
GRANT ALL PRIVILEGES ON *.* TO wvdon;
```

创建用户：

```sql
CREATE USER wvdon1 identified by '123456';
```

查询权限

```sql
SHOW GRANTS FOR wvdon ;
SHOW GRANTS FOR root@localhost;
```

撤销权限:

```
-- 撤销权限 REVOKE 权限 ，那个库，给谁撤销
REVOKE ALL PRIVILEGES  ON *.* FROM wvdon;

```

删除用户:

`drop user wvdon`

## 规范数据库的设计

> 软件开发中，关于数据库的设计：

- 分析需求：分析业务和需要处理数据库的需求
- 概要设计：设计关系图E-R图

> 设计数据库的步骤（个人博客）

- 收集信息，分析需求
  - 用户表（用户登录注销，用户的个人信息，写博客，创建分类）
  - 分类表（文字分类，谁创建的）
  - 文字表（文字的信息）
  - 友链表
  - 自定义表（系统信息，或者一些主地段。Key:value）
- 表示实体（把需求落实到每个字段）
- 标识实体之间的关系。
  - 写博客：user—>blog
  - 创建分类：user—>category

### 三大范式 设计规范

> 为什么需要数据规范化

- 信息重复
- 更新异常
- 插入异常
  - 无法正常显示信息
- 删除异常
  - 丢失有效的信息

> 三范式

第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。

第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）

第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关

[关系型数据库设计：三大范式的通俗理解](https://blog.csdn.net/Alice_8899/article/details/105358158)

> 规范性和性能的问题（规范数据库的设计）

关联查询的表不得超过三张表

- 考虑商业化的需求和目标、**数据库的性能更加重要**
- 在规范性能问题的时候，需要适当考虑一下规范性！
- 故意给某些表增加一些冗余的字段（多表查询中变为单表查询）
- 故意增加一些计算列（从大数据量降低为小数据量的查询：索引）

## JDBC

|SQL注入的问题

`or 1=1`

> 数据库连接池 实现datasource

每次连接和释放，是十分浪费资源的。

池化技术：准备一些预先的资源，过来就连接预先准备好的。

     设置，最小，最大连接数，等待超时

# 实际案例：

创建100万条sql数据：

创建表：

```sql
CREATE TABLE `app_user` (
                            `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
                            `name` VARCHAR(50) DEFAULT'' COMMENT'用户昵称',
                            `email` VARCHAR(50) NOT NULL COMMENT'用户邮箱',
                            `phone` VARCHAR(20) DEFAULT'' COMMENT'手机号',
                            `gender` TINYINT(4) UNSIGNED DEFAULT '0'COMMENT '性别（0：男;1:女）',
                            `password` VARCHAR(100) NOT NULL COMMENT '密码',
                            `age` TINYINT(4) DEFAULT'0'  COMMENT '年龄',
                            `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
                            `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                            PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT = 'app用户表';
```

插入数据：

```sql
-- 插入100万数据.
DELIMITER $$ -- 写函数之前必须要写，标志
CREATE FUNCTION mock_data_2 ()
RETURNS INT
BEGIN
    DECLARE num INT DEFAULT 1000000;
    DECLARE i INT DEFAULT 0;
    WHILE i<num DO
            INSERT INTO `app_user`(`name`,`email`,`phone`,`gender`,`password`,`age`)
            VALUES(CONCAT('用户',i),'mail@wvdon.com',CONCAT('18',floor(rand()*(999999999-100000000)+100000000)),FLOOR(RAND()*2),UUID(),floor(RAND()*100));
            SET i=i+1;
        END WHILE;
    RETURN i;
END;
SELECT mock_data_2() ;-- 执行此函数 生成一百万条数据
```

> 此时如果去查询的话，会非常慢。

`SELECT * FROM app_user WHERE name='用户99999';`

1 row retrieved starting from 1 in 655 ms (execution: 638 ms, fetching: 17 ms)

> 解决方法

建立索引。

`CREATE INDEX id_app_user_name ON app_user(name);`

## 核算检测数据库设计总结：

check_info:

```sql
CREATE TABLE `check_info`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `id_card` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '身份证号',
  `check_place_id` int(11) NULL DEFAULT NULL COMMENT '检测点id',
  `agency_serial_code` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '试管编号',
  `check_org_id` int(11) NULL DEFAULT NULL COMMENT '检测机构id',
  `check_op_mobile` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '检测人手机号',
  `check_status` int(4) NULL DEFAULT NULL COMMENT '1已报名-未检测 2已检测 ',
  `sampling_time` datetime NULL DEFAULT NULL COMMENT '采样时间',
  `report_time` datetime NULL DEFAULT NULL COMMENT '报告生成时间',
  `activy_id` int(11) NULL DEFAULT NULL COMMENT '活动id',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `create_user` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '创建用户',
  `update_user` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '最后更新用户',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_activy_id_card`(`id_card`, `activy_id`) USING BTREE,
  INDEX `idx_activy_id_serial`(`agency_serial_code`, `activy_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11428803 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '检测信息' ROW_FORMAT = DYNAMIC;
```

# LeetCode

176. 第二高的薪水

```sql
# Write your MySQL query statement below
SELECT (SELECT DISTINCT Salary  from Employee 
ORDER BY Salary DESC 
limit 1,1)  AS SecondHighestSalary;
```

通过多加一个SELECT来判断是否为空，空的时候 SELECT是NULL

空值和NULL的区别：

- 占用空间
- 插入、查询方法

[链接](https://zhuanlan.zhihu.com/p/72039985#:~:text=NULL%E5%88%97%E9%9C%80%E8%A6%81%E8%A1%8C%E4%B8%AD%E7%9A%84%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E6%9D%A5%E8%AE%B0%E5%BD%95%E5%AE%83%E4%BB%AC%E7%9A%84%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BANULL%E3%80%82%20%E9%80%9A%E4%BF%97%E7%9A%84%E8%AE%B2%EF%BC%9A%E7%A9%BA%E5%80%BC%E5%B0%B1%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E7%9C%9F%E7%A9%BA%E8%BD%AC%E6%80%81%E6%9D%AF%E5%AD%90%EF%BC%8C%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%EF%BC%8C%E8%80%8CNULL%E5%80%BC%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E8%A3%85%E6%BB%A1%E7%A9%BA%E6%B0%94%E7%9A%84%E6%9D%AF%E5%AD%90%EF%BC%8C%E8%99%BD%E7%84%B6%E7%9C%8B%E8%B5%B7%E6%9D%A5%E9%83%BD%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%89%E7%9D%80%E6%9C%AC%E8%B4%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%20mysql%3E%20INSERT%20tb_test%20VALUES%20%28NULL%2CNULL%29%3B%201048,SELECT%20%2A%20FROM%20tb_test%20where%20one%20%21%3D%20%27%27%3B)

175. 组合两个表

```sql
# Write your MySQL query statement below
SELECT FirstName, LastName, A.City, A.State FROM Person AS P LEFT JOIN Address AS A
ON P.PersonID=A.PersonId;
```

****[177. 第N高的薪水](https://leetcode-cn.com/problems/nth-highest-salary/)****

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  declare NUM INT;
  SET NUM = N-1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT (SELECT DISTINCT Salary  from Employee 
                    ORDER BY Salary DESC 
                    limit NUM,1)  AS SecondHighestSalary
  );
END
```

1.limit不能进行运算

要单独定义一个int变量

2.创建sql函数的格式

[178. 分数排名](https://leetcode-cn.com/problems/rank-scores/)

```sql
select a.Score as Score,
(select count(distinct b.Score) from Scores b where b.Score >= a.Score) as Rank
from Scores a
order by a.Score DESC
```

郑州市第一轮核酸检测技术支持。

负责工作：同步郑州市1200万人员信息。收集核算结果数据600万余份。

疫情SQL star:





